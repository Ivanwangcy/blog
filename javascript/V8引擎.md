# V8 引擎

## 前言

V8引擎对于大多数前端开发人员来说非常熟悉了。它师出名门，是 Google 公司开发的高性能引擎。大名鼎鼎的 Node.js 就是基于 V8 引擎开发的，对前端开发比较友好的 Chrome 浏览器也有它的影子，甚至还实现了前端的 ES 规范和 WebAssembly 规范。有了它可以让我们在各种平台上运行 javascript 代码。

## V8 引擎的诞生

V8 是谷歌开源的一个基于C++语言开发的JavaScript引擎，可以实现ECMA-262中规定的 ECMAScript，其被用于谷歌浏览器chrome，安卓浏览器，node.js等大型项目当中，V8 引擎可以独立运行不依赖于其他环境，也可以嵌入任何的 C++ 应用当中使用。

V8 最早被开发用以嵌入到 Google 的开源浏览器 Chrome 中，第一个版本随着第一版Chrome于 2008 年 9 月 2 日发布。但是 V8 是一个可以独立运行的模块，完全可以嵌入到任何 C ++应用程序中。著名的 Node.js( 一个异步的服务器框架，可以在服务端使用 JavaScript 写出高效的网络服务器 ) 就是基于 V8 引擎的，Couchbase, MongoDB 也使用了 V8 引擎。

V8 会编译 / 执行 JavaScript 代码，管理内存，负责垃圾回收，与宿主语言的交互等。通过暴露宿主对象 ( 变量，函数等 ) 到 JavaScript，JavaScript 可以访问宿主环境中的对象，并在脚本中完成对宿主对象的操作。

V8支持众多操作系统，如windows、linux、android等，也支持其他硬件架构，如IA32,X64,ARM等，具有很好的可移植和跨平台特性。

## V8 的工作流程

V8引擎在执行JavaScript的过程中，主要有两个阶段：编译和运行，与C++的执行前完全编译不同的是，JavaScript需要在用户使用时完成编译和执行。在V8中，JavaScript相关代码并非一下完成编译的，而是在某些代码需要执行时，才会进行编译，这就提高了响应时间，减少了时间开销。在V8引擎中，源代码先被解析器转变为抽象语法树(AST)，然后使用JIT编译器的全代码生成器从AST直接生成本地可执行代码。这个过程不同于JAVA先生成字节码或中间表示，减少了AST到字节码的转换时间，提高了代码的执行速度。但由于缺少了转换为字节码这一中间过程，也就减少了优化代码的机会。

V8 将JavaScript代码进行编译，生成抽象语法树（AST），对作用域进行分析，分辨出局部变量或全局变量，再通过JIT技术将语法树直接转换成原生代码，没有经过字节码的编译，节省了编译时间，得到了不是最优的代码，其后通过数据分析器挑选使用频率高的代码进行优化，若优化后的效果不如之前的话就进行优化回滚。

V8 是一个非常复杂的项目，有超过 100 万行 C++代码。它由许多子模块构成，其中这 4 个模块是最重要的：

Parser： 将 JS 源码转换为 AST，然后 Ignition 将 AST 转换为 Bytecode，最后 TurboFan 将 Bytecode 转换为经过优化的 Machine Code(实际上是汇编代码)。

V8引擎编译本地代码时使用的主要类如下所示：

Script：表示JavaScript代码，即包含源代码，又包含编译之后生成的本地代码，即是编译入口，又是运行入口；
Compiler：编译器类，辅组Script类来编译生成代码，调用解释器(Parser)来生成AST和全代码生成器，将AST转变为本地代码；
AstNode：抽象语法树节点类，是其他所有节点的基类，包含非常多的子类，后面会针对不同的子类生成不同的本地代码；
AstVisitor：抽象语法树的访问者类，主要用来遍历异构的抽象语法树；
FullCodeGenerator：AstVisitor类的子类，通过遍历AST来为JavaScript生成本地可执行代码。
JavaScript代码编译的过程大致为：Script类调用Compiler类的Compile函数为其生成本地代码。Compile函数先使用Parser类生成AST，再使用FullCodeGenerator类来生成本地代码。本地代码与具体的硬件平台密切相关，FullCodeGenerator使用多个后端来生成与平台相匹配的本地汇编代码。由于FullCodeGenerator通过遍历AST来为每个节点生成相应的汇编代码，缺失了全局视图，节点之间的优化也就无从谈起。

在执行编译之前，V8会构建众多全局对象并加载一些内置的库（如math库），来构建一个运行环境。而且在JavaScript源代码中，并非所有的函数都被编译生成本地代码，而是延迟编译，在调用时才会编译。

由于V8缺少了生成中间代码这一环节，缺少了必要的优化，为了提升性能，V8会在生成本地代码后，使用数据分析器(profiler)采集一些信息，然后根据这些数据将本地代码进行优化，生成更高效的本地代码，这是一个逐步改进的过程。同时，当发现优化后代码的性能还不如未优化的代码，V8将退回原来的代码，也就是优化回滚。下面介绍一下运行阶段，该阶段使用的主要类如下所示：

Script：表示JavaScript代码，即包含源代码，又包含编译之后生成的本地代码，即是编译入口，又是运行入口；
Execution：运行代码的辅组类，包含一些重要函数，如Call函数，它辅组进入和执行Script代码；
JSFunction：需要执行的JavaScript函数表示类；
Runtime：运行这些本地代码的辅组类，主要提供运行时所需的辅组函数，如：属性访问、类型转换、编译、算术、位操作、比较、正则表达式等；
Heap：运行本地代码需要使用的内存堆类；
MarkCompactCollector：垃圾回收机制的主要实现类，用来标记、清除和整理等基本的垃圾回收过程；
SweeperThread：负责垃圾回收的线程。

先根据需要编译和生成这些本地代码，也就是使用编译阶段那些类和操作。在V8中，函数是一个基本单位，当某个JavaScript函数被调用时，V8会查找该函数是否已经生成本地代码，如果已经生成，则直接调用该函数。否则，V8引擎会生成属于该函数的本地代码。这就节约了时间，减少了处理那些使用不到的代码的时间。其次，执行编译后的代码为JavaScript构建JS对象，这需要Runtime类来辅组创建对象，并需要从Heap类分配内存。再次，借助Runtime类中的辅组函数来完成一些功能，如属性访问等。最后，将不用的空间进行标记清除和垃圾回收。

Ignition + TurboFan 的组合，就是字节码解释器 + JIT 编译器的黄金组合。这一黄金组合在很多 JS 引擎中都有所使用，例如微软的 Chakra，它首先解释执行字节码，然后观察执行情况，如果发现热点代码，那么后台的 JIT 就把字节码编译成高效代码，之后便只执行高效代码而不再解释执行字节码。苹果公司的 SquirrelFish Extreme 也引入了 JIT。SpiderMonkey 更是如此，所有 JS 代码最初都是被解释器解释执行的，解释器同时收集执行信息，当它发现代码变热了之后，JaegerMonkey、IonMonkey 等 JIT 便登场，来编译生成高效的机器码。

## 优化你的代码

了解 V8 引擎的工作原理有助于优化你 JavaScript 代码。TurboFan 的优化通过减轻糟糕的 JavaScript 的影响来提高 JavaScript 的网络性能。然而，了解这些优化可以提供进一步的加速。

下面是利用V8中的优化来提高性能的 7 个技巧。前四个重点是减少去优化。

Tip1: 在构造函数中声明对象属性
更改对象属性会产生新的隐藏类。以google i/o 2012中的以下示例为例。

class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}

var p1 = new Point(11, 22);  // hidden class Point created
var p2 = new Point(33, 44);

p1.z = 55;  // another hidden class Point created

正如你所见，p1和p2现在有不同的隐藏类了。这阻碍了TurboFan的优化尝试：具体来说，任何接受Point对象的方法现在都是去优化的。

所有这些函数都使用两个隐藏类重新优化。对对象形状的任何修改都是如此。

Tip2: 保持对象属性不变
更改对象属性的顺序会导致新的隐藏类，因为对象形状中是包含顺序的。

const a1 = { a: 1 };  # hidden class a1 created
a1.b = 3;

const a2 = { b: 3 };  # different hidden class a2 created
a2.a = 1;


上面的代码中，a1和a2有不同的隐藏类。修复顺序允许编译器重用同一个隐藏类。因为添加的字段（包括顺序）用于生成隐藏类的id

Tip3：修复函数参数类型
函数根据特定参数位置的值类型更改对象形状。如果此类型发生更改，则函数将去优化并重新优化。

在看到四种不同的对象形状后，该函数会变成megamorphic，TurboFan将不会再尝试优化这个函数。

看下面这个例子：

function add(x, y) {
  return x + y
}

add(1, 2);  # monomorphic
add("a", "b");  # polymorphic
add(true, false);
add([], []);
add({}, {});  # megamorphic

第9行过后，TurboFan将不会再优化add这个函数。

Tip4：在脚本作用域中声明类
不要在函数作用域中声明类。以下面这个例子为例：

function createPoint(x, y) {
  class Point {
    constructor(x, y) {
      this.x = x;
      this.y = y;
    }
  }
  return new Point(x, y);
}

function length(point) {
  ...
}

每一次createPoint这个函数被调用的时候，一个新的Point原型会被创建。

每一个新的原型都对应着一个新的对象形状，所以每一次length函数都会看到一个新的point的对象形状。

跟之前一样，当看到4个不同的对象形状的时候，函数会变得megamorphic，TurboFan将不会再尝试优化

length函数。

在脚本作用域中声明class Point，我们可以避免每一次调用createPoint的时候，生成不同的对象形状。

下一个tip是V8引擎里的奇淫巧技。

Tip5：使用for…in
这是V8引擎中的一个怪异行为。这一特性之前包含在最初的Crankshaft里面，后来被移植到了Ignition and Turbofan.

for…in循环比函数迭代、带箭头函数的函数迭代和for循环中的object.keys快4-6倍。

接下来两个Tip是对之前两种说法的反驳。由于现代V8引擎的改变，这两种说法已经不成立了。

Tip6：无关字符不影响性能
Crankshaft过去是使用一个函数的字节数来决定是否内联一个函数的。而TurboFan是建立在AST上的，他使用AST节点的数量来决定函数的大小。

因此，无关的字符，比如空白，注释，变量名长度，函数签名等，不会影响函数的性能。

Tip7：Try/catch/finally 不是毁灭性的
Try代码块以前容易出现高昂的优化-去优化的周期。如今，当在Try块中调用函数时，turbofan不再显示出显著的性能影响。

## V8 性能优化

## V8 调试


> 浅读 V8 ——强大的JavaScript引擎: <https://www.jianshu.com/p/332c15fd7c7d>
> js中 v8 引擎的详解: <https://www.jianshu.com/p/0ab973761b8a>
> 认识 V8 引擎: <https://zhuanlan.zhihu.com/p/27628685>
> 浏览器是如何工作的：Chrome V8 让你更懂 JavaScript: <https://segmentfault.com/a/1190000037435824>
> V8 优化小贴士 <https://jiongks.name/blog/v8-javascript-performance-tips/>