# RegExp 正则表达式

## 过滤特殊字符

```javascript
 var reg = /^[\u4e00-\u9fa5\w\#\-\/\(\)（），。？]+$/; 包含汉字。。验证
// 验证特殊字符
if (input_blessing && !reg.test(input_blessing)) {
  msg('备注不可以输入特殊字符');
  return d.reject();
}
```

## 中文匹配

```javascript
/^[\u4e00-\u9fa5]+$/
/^[\u4e00-\u9fa5]+$/.test("我是中文") // 不包含中文标点符号
-> true
```

## 工作中常用正则表达式

```javascript
var myPattern: RegExp = /[\u4e00-\u9fa5]+/gi; //汉字匹配表达式

var myPattern: RegExp = new RegExp("\\W" + str + "\\W", "i"); //字符串变量匹配, 匹配所有单词

new RegExp("\\s" + value + "\\s", "gi"); //匹配空白符隔开的单词

myPattern = new RegExp("\\b" + str + "\\b", "gi"); //匹配单词

var myPattern: RegExp = /(\w+)\'(\w+)*/gi; //单词匹配 (带'单词)

var reg = /^[^\uD800-\uDBFF]+$/; // 过滤表情符号，表情符号是以 D800 开头 -  DBFF 结尾的4字节字符

/**
 * [regEmoji 非表情符号验证正则表达式 表情符号为4字节字符，长度为2，从D800-DBFF开头的]
 * @type {RegExp}
 * 😘😁😜😆😍 (这些特殊字符为表情符号)返回 false
 * 其它文字都返回 true
 */
var regEmoji = /^[^\uD800-\uDBFF]+$/; //
```

## app 端特殊字符过滤(Android)：

```JavaScript
var reg = "^[A-Za-z\\d\\u4E00-\\u9FA5\\p{P}‘’“”\\s]+$"; \p{P}标点符号等特殊字符， JavaScript中无效（不支持？）
```

## 正则分组 取词

`$_, $1, $2, $n`

```js
"abc".replace(/(a)(\w+)/, "$2-$1");
```

## 正则分组 引用 `\(1-n)`

使用 `\(number)` 表示引用之前匹配过的正则分组。

```js
"2018-03-03".match(/(\d{4})-(\d{2})-\2/);
// 第一个括号 代表 \1
// 第二个括号 代表 \2
// true
"2018-03-05".match(/(\d{4})-(\d{2})-\2/);
// false
"2018-03-05".match(/(\d{4})-(\d{2})-(\d{2})/);
// true
```

## 正则分组 - 命名分组

```js
// 使用 ?<分组名称>
"2018-03-03".match(/(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/);

// 获取命名分组匹配项
"2018-03-03".replace(/(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/, '$<year>——$<month>——$<day>');

// 命名分组的好处是，可以无序的
"2018-03-03".replace(/(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/, '$<day>——$<month>——$<year>');
// 命名分组引用 \k<分组名称>
"2018-03-03".match(/(?<year>\d{4})-(?<month>\d{2})-\k<month>/);
```

## 正则分组 捕获/不捕获

?:和?= 都用于子表达式里面，?:表示匹配且获取，?=表示匹配但不获取。

(?=) 正常的括号是捕获的
(?:) 不捕获分组(不在分组中显示) 不会放入这些里面 $1-$9
例如：

```js
/1(?:2)/ // 匹配12

/1(?=2)/ // 匹配1，而且是后面有2的那个1
```

## 惰性&贪婪

1.  贪婪模式 -- 在匹配成功的前提下，尽可能多的去匹配
2.  惰性模式 -- 在匹配成功的前提下，尽可能少的去匹配
3.  `/.*bbb/g`
4.  `/.*?bbb/g` 惰性 多一个 `？`

## 邮箱验证示例

```js
/^\w(?:[-\w\.](?![-\.]))*\w@[-\w]+(\.\w+)+$/i.test("a.a@qq.com.cn");
```

## IP 地址 正则表达式

> 关键字：IP 地址 正则表达式作者：txw1958
> 出处：http://www.cnblogs.com/txw1958/archive/2011/10/13/ip_address_regular_expression.html

IP 地址的长度为 32 位，分为 4 段，每段 8 位，用十进制数字表示，每段数字范围为 0~255，段与段之间用英文句点“.”隔开。例如：某台计算机 IP 地址为 10.11.44.100。

分析 IP 地址的组成特点：250-255、200-249、0-199。这三种情况可以分开考虑，

1.  250-255：特点：三位数，百位是 2，十位是 5，个位是 0~5，用正则表达式可以写成：25[0-5]
2.  200-249：特点：三位数，百位是 2，十位是 0~4，个位是 0~9，用正则表达式可以写成：2[0-4]\d
3.  0-199：这个可以继续分拆，这样写起来更加简单明了.
    3.1. 0-9： 特点：一位数，个位是 0~9，用正则表达式可以写成：\d
    3.2. 10-99： 特点：二位数，十位是 1~9，个位是 0~9，用正则表达式可以写成：[1-9]\d
    3.3. 100-199：特点：三位数，百位是 1，十位是 0~9，个位是 0~9，用正则表达式可以写成：1\d{2}

于是 0-99 的正则表达式可以合写为[1-9]?\d，那么 0-199 用正则表达式就可以写成(1\d{2})|([1-9]?\d)，这样 0~255 的正则表达式就可以写成(25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d)))
最后，前面 3 段加上句点.可以使用{3}重复得到，第 4 段再来一次同样的匹配，得到 IP 地址的正则表达式：

``js
((?:(?:25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d)))\.){3}(?:25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d))))

```
与大家互动一下：

1.  为什么三位数的匹配放在二位数/一位数的前面？因为正则表达式规则之一：最先开始的匹配拥有最高的优先权。
2.  0.0.0.0和255.255.255.255是合法存在的IP地址，你知道是为什么吗？
3.  192.169.01.108这种数字前面多带了个0的类型的，在这里不是合法的，为什么要这样？
4.  为什么前面在最前面要有?:呢？它在这里有什么用？
5.  如果您发现本表达式有错误，也请留言指正！

我使用的正则表达式验证工具，The Regulator 下载地址：[regulator](http://sourceforge.net/projects/regulator/)
```
